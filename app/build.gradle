plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
    alias(libs.plugins.kotlin.kapt)
}

// Apply Firebase plugins only if google-services.json is present
def hasGoogleServices = file("google-services.json").exists()
if (hasGoogleServices) {
    apply plugin: 'com.google.gms.google-services'
    apply plugin: 'com.google.firebase.crashlytics'
}

android {
    namespace "com.repasdelaflemme.app"
    compileSdk 35

    defaultConfig {
        applicationId "com.repasdelaflemme.app"  // âœ… Changez en "com.repasdelaflemme.app"
        minSdk 24
        targetSdk 35
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables { useSupportLibrary true }
    }

    buildTypes {
        debug {
            debuggable true
            minifyEnabled false
            buildConfigField "Boolean", "ENABLE_LOGGING", "true"
            buildConfigField "Boolean", "GENERATE_SYNTHETIC_RECIPES", "true"
            if (hasGoogleServices) {
                firebaseCrashlytics {
                    mappingFileUploadEnabled false
                }
            }
        }
        release {
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            buildConfigField "Boolean", "ENABLE_LOGGING", "false"
            buildConfigField "Boolean", "GENERATE_SYNTHETIC_RECIPES", "false"
            if (hasGoogleServices) {
                firebaseCrashlytics {
                    mappingFileUploadEnabled true
                }
            }
        }
    }

    buildFeatures {
        viewBinding true
        buildConfig true
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }
    kotlinOptions {
        jvmTarget = "17"
    }

    packaging {
        resources {
            excludes += ["/META-INF/{AL2.0,LGPL2.1}"]
        }
    }
}

dependencies {
    // AndroidX Core
    implementation libs.appcompat
    implementation libs.material
    implementation libs.constraintlayout
    implementation libs.recyclerview
    implementation libs.cardview

    // Lifecycle
    implementation libs.lifecycle.viewmodel
    implementation libs.lifecycle.livedata

    // Navigation
    implementation libs.navigation.fragment
    implementation libs.navigation.ui

    // Room
    implementation libs.room.runtime
    implementation libs.room.ktx
    kapt libs.room.compiler

    // Gson
    implementation libs.gson

    // Glide
    implementation libs.glide
    annotationProcessor libs.glide.compiler

    // Timber
    implementation libs.timber

    // Network / Retrofit
    implementation libs.retrofit
    implementation libs.converter.gson
    implementation libs.okhttp.logging

    // Coroutines
    implementation libs.kotlinx.coroutines.android

    // Firebase Crashlytics (conditional by presence of google-services.json at build time)
    implementation platform(libs.firebase.bom)
    implementation libs.firebase.crashlytics
    implementation libs.firebase.analytics

    // Testing
    testImplementation libs.junit
    testImplementation libs.androidx.arch.core.testing
    testImplementation libs.mockito.core
    androidTestImplementation libs.androidx.test.ext.junit
    androidTestImplementation libs.androidx.test.espresso.core
}

// ---- Utility: verify that embedded recipe images are present in res/drawable ----
def requiredRecipeImages = [
        'photo_pasta',
        'photo_omelette',
        'photo_fried_rice',
        'photo_curry',
        'photo_salad',
        'photo_ratatouille',
        'photo_carbonara',
        'photo_pad_thai',
        'photo_couscous'
]

tasks.register('verifyRecipeImages') {
    group = 'verification'
    description = 'Checks presence of embedded recipe photos in res/drawable.'
    doLast {
        def resDirs = android.sourceSets.main.res.srcDirs
        def allowedExt = ['.png', '.jpg', '.jpeg', '.webp', '.avif']
        def found = [:]
        requiredRecipeImages.each { found[it] = false }

        resDirs.each { base ->
            requiredRecipeImages.each { name ->
                allowedExt.each { ext ->
                    def f = new File(base, "drawable/${name}${ext}")
                    if (f.exists()) {
                        found[name] = true
                    }
                }
            }
        }

        def missing = found.findAll { !it.value }.collect { it.key }
        if (!missing.isEmpty()) {
            println "WARNING: Missing recipe images in res/drawable: ${missing}"
            // Fail builds other than debug unless opt-out flag is provided
            def isDebugBuild = gradle.startParameter.taskNames.any { it.toLowerCase().contains('debug') }
            def allowBypass = project.hasProperty('allowMissingRecipeImages')
            if (!isDebugBuild && !allowBypass) {
                throw new GradleException("Missing embedded recipe images: ${missing}. Add them under app/src/main/res/drawable or pass -PallowMissingRecipeImages to bypass.")
            }
        } else {
            println 'All embedded recipe images are present.'
        }
    }
}

// Run check before building; can bypass with -PallowMissingRecipeImages
tasks.matching { it.name == 'preBuild' }.configureEach { dependsOn tasks.named('verifyRecipeImages') }

// ---- Utility: import photos from a local folder and rename to expected names ----
tasks.register('importRecipeImages') {
    group = 'assets'
    description = 'Import photos from app/recipe_images_input into res/drawable with expected names.'
    doLast {
        def inDir = new File(projectDir, 'recipe_images_input')
        if (!inDir.exists()) {
            println "Place your files in ${inDir} named with keywords: pasta, omelette, fried, curry, carbonara, pad, couscous, salad, ratatouille."
            inDir.mkdirs()
            return
        }
        def outDir = android.sourceSets.main.res.srcDirs.collect { new File(it, 'drawable') }.find { it.exists() } ?: new File(projectDir, 'src/main/res/drawable')
        outDir.mkdirs()
        def mapping = [
                'pasta':'photo_pasta',
                'omelette':'photo_omelette',
                'fried':'photo_fried_rice',
                'curry':'photo_curry',
                'carbonara':'photo_carbonara',
                'pad':'photo_pad_thai',
                'couscous':'photo_couscous',
                'salad':'photo_salad',
                'ratatouille':'photo_ratatouille'
        ]
        def copied = []
        inDir.listFiles(new FilenameFilter(){ boolean accept(File d, String n){ n.toLowerCase().matches('.*\\.(png|jpe?g|webp|avif)$') } }).each { f ->
            def nameLower = f.name.toLowerCase()
            mapping.find { k, v -> nameLower.contains(k) }?.with { k, v ->
                def ext = f.name.lastIndexOf('.') >= 0 ? f.name.substring(f.name.lastIndexOf('.')) : '.jpg'
                def dest = new File(outDir, v + ext)
                f.withInputStream { ins -> dest.withOutputStream { outs -> outs << ins } }
                copied << dest.name
            }
        }
        if (copied.isEmpty()) println 'No matching files found in recipe_images_input.' else println "Imported: ${copied}";
    }
}
